<h2>물리 데이터저장소 구성</h2>
<div class="well">
    물리 데이터 저장소 설계에 따라 데이터 저장소에 실제 제이터가 저장될 물리적 공간을 구성할 수 있다.
</div>


<h3>1. 테이블 제약조건</h3>

<h4>1. Delete Constraint</h4>
<ul>
    <li>참조된 기본키의 값이 삭제될 경우의 처리내용을 정의한다.</li>
    <li>Cascade: 참조한 테이블에 있는 외부키와 일치하는 모든 Row가 삭제된다.</li>
    <li>Restricted: 참조한 테이블에 있는 외부키에 없는 것만 삭제 가능하다.</li>
    <li>Nullify: 참조한 테이블에 정의된 외부키와 일치하는 것을 Null로 수정한다.</li>
</ul>

<h4>2. Update Constraint</h4>
<ul>
    <li>참조된 기본키의 값이 수정될 경우의 처리내용을 정의한다.</li>
    <li>Cascade: 참조한 테이블에 있는 외부키와 일치하는 모든 Row가 수정된다.</li>
    <li>Restricted: 참조한 테이블에 있는 외부키에 없는 것만 수정가능하다.</li>
    <li>Nullify: 참조한 테이블에 정의된 외부키와 일치하는 것을 Null로 수정한다.(해당 칼럼이 Null을 허용할 경우만)</li>
</ul>


<h3>2. 인덱스 설계</h3>
<h4>1. 인덱스 적용 기준</h4>
<ul>
    <li>인덱스 칼럼의 분포도가 10 ~ 15% 이내인 경우</li>
    <li>분포도 = ( 1 / 칼럼값의 종류 ) X 100 = (칼럼값의 평균 Row수 / 테이블의 총 Row수 ) X 100</li>
    <li>분포도가 범위 이상이더라도 부분처리를 목적으로 하는 경우</li>
    <li>입출력장표 등에서 조회 및 출력조건으로 사용되는 칼럼 인 경우</li>
    <li>인덱스가 자동 생성되는 기본키와 Unique키의 제약조건을 사용할 경우</li>
</ul>
<h4>2. 인덱스 칼럼 선정</h4>
<ul>
    <li>분포도가 좋은 칼럼은 단독적으로 생성하여 활용도를 향상시킨다.</li>
    <li>자주 조합되어 사용되는 칼럼은 결합 인덱스로 생성하여 활용한다.</li>
    <li>결합 인덱스는 구성되는 칼럼순서 선정(사용빈도, 유일성, Sort,...)에 유의해야 한다.</li>
    <li>가능한 한 수정이 빈번하지 않은 칼럼을 선정한다.</li>
</ul>
<h4>3. 설계시 고려사항</h4>
<ul>
    <li>새로 추가되는 인덱스가 기존 액세스 경로에 영향을 미칠 수 있음에 유의한다.</li>
    <li>지나치게 많은 인덱스는 오버헤드로 작용한다.</li>
    <li>인덱스는 추가적인 저장공간이 필요함을 고려해야 한다.</li>
    <li>넓은 범위를 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킬 수 있 음에 유의해야 한다.</li>
    <li>인덱스와 테이블 데이터의 저장 공간을 적절히 분리될 수 있도록 설계해야 한다.</li>
</ul>


<h3>3. 뷰 설계</h3>
<h4>1. 뷰 속성</h4>
<ul>
    <li>REPLACE: 뷰가 이미 존재하는 경우 재생성</li>
    <li>FORCE: 기본 테이블의 존재 여부에 관계 없이 뷰 생성</li>
    <li>NOFORCE: 기본 테이블이 존재할 때 만 뷰 생성</li>
    <li>WITH CHECK OPTION: Sub-Query 내의 조건을 만족하는 행만 변경</li>
    <li>WITH READ ONLY: DML 작업 불가</li>
</ul>

<h4>2. 뷰 설계 시 고려사항</h4>
<ul>
    <li>최종적으로는 테이블을 액세스하는 것이므로 사용에 따라 수행속도에 문제가 발생할 수 있다.</li>
    <li>뷰내의 SELECT 문의 조건은 가능한 한 최적의 액세스 경로를 사용할 수 있도록 하거나 그럴 수 없다면 뷰를 사용한 SQL의 WHERE 절에서는 반드시 양호한 액세스 경로가 되도록 하여야 한다.</li>
</ul>


<h3>4. 클러스터 설계</h3>
<h4>1. 적용 기준</h4>
<ul>
    <li>분포도가 넓을수록 오히려 유리(인덱스의 단점을 해결)한 기법</li>
    <li>액세스 기법이 아니라 액세스 효율 향상을 위한 물리적 저장 방법</li>
    <li>분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약 가능</li>
    <li>다중 블록 이상의 테이블에 적용</li>
    <li>대량의 범위를 자주 액세스하는 경우 적용</li>
    <li>인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용</li>
    <li>여러개의 테이블이 번번히 조인을 일으킬 때 활용</li>
    <li>반복 칼럼이 정규화에 의해 어쩔 수 없이 분할된 경우 활용</li>
</ul>
<h4>2. 클러스터 설계시 고려사항</h4>
<ul>
    <li>검색 효율은 높여 주나 입력, 수정, 삭제 시는 부하가 증가함을 고려하여야 한다.</li>
    <li>Union, Distinct, Order by, Group by가 빈번한 칼럼이면 고려해 보아야 한다.</li>
    <li>수정이 자주 발생하지 않는 칼럼은 고려 대상이다.</li>
    <li>처리 범위가 넓어 문제가 발생하는 경우는 단일 테이블 클러스터링을, 조인이 많아 문제가 발생되는 경우는 다중 테이블 클러스터링을 고려하여야 한다.</li>
</ul>


<h3>5. 파티션 설계</h3>
<h4>1. 파티션 종류</h4>
<ul>
    <li><em>범위분할(Range Partitioning)</em>: 지정한 열의 값을 기준으로 분할</li>
    <li><em>해시분할(Hash Partitioning)</em>: 해시 함수에 따라 데이터를 분할</li>
    <li><em>조합분할(Composite Partitioning)</em>: 범위분할에 의해 데이터를 분할한 다음 해시 함수를 적용하여 다시 분할</li>
</ul>

<h4>2. 장점</h4>
<ul>
    <li>데이터 액세스 범위를 줄여 성능 향상</li>
    <li>전체 데이터의 훼손가능성이 감소 및 데이터 가용성 향상</li>
    <li>각 분할 영역을 독립적으로 백업하고 복구가능</li>
    <li>Disk Striping로 I/O 성능을 향상(Disk 컨트롤러에 대한 경합의 감소)</li>
</ul>

<h4>3. 파티셔닝 순서</h4>
<ul>
    <li>파티션의 종류 결정</li>
    <li>파티션 키의 선정
        <ul>
            <li>I/O 분산을 어떻게 할 것인가를 고려하여 선정한다.</li>
            <li>액세스 유형에 따라 파티셔닝이 이루어질 수 있도록 파티션 키를 선정한다.</li>
            <li>이력 데이터의 경우, 생성주기 또는 소멸주기가 파티션과 일치하도록 한다.</li>
        </ul>
    </li>
    <li>파티션 수의 결정</li>
</ul>



<h3>6. 디스크 구성 설계</h3>
<ul>
    <li>정확한 용량을 산정하여 디스크 사용의 효율을 높인다.</li>
    <li>업무량이 집중되어 있는 디스크를 분리하여 설계함으로써 집중화된 디스크에 대한 입출 력 부하를 분산한다.</li>
    <li>입출력 경합을 최소화하여 데이터의 접근 성능을 향상시킨다.
        <ul>
            <li>테이블 객체를 위한 테이블 스페이스와 인덱스 객체를 위한 테이블스페이스를 분리 구성한다.</li>
            <li>테이블 스페이스와 템포러리 스페이스를 분리 구성한다.</li>
            <li>테이블을 마스터 테이블과 트랜잭션 테이블로 분류한다.</li>
        </ul>
    </li>
    <li>시스템의 구성(Disk의 구성)에 따라 테이블스페이스의 개수와 사이즈 등을 결정한다.</li>
    <li>파티션할 테이블은 별도로 분류한다.</li>
</ul>



<h3>문제풀기</h3>
<div class="well">데이터 레코드에 빠르게 접근하기 위해 키 값, 포인터 쌍으로 구성되어 있는 데이터 구조를 무엇이라고 하는가?</div>
<a href="#" class="btna">
    <span class="text">Text</span>
    <span class="flip-front">정답확인</span>
    <span class="flip-back">인덱스 설계</span>
</a>
<br><br>

<div class="well">하나 이상의 테이블에서 원하는 모든 데이터를 선택하여 사용자에 의하여 정의된 가상의 테이블을 무엇이라고 하는가?</div>
<a href="#" class="btna">
    <span class="text">Text</span>
    <span class="flip-front">정답확인</span>
    <span class="flip-back">뷰(view)</span>
</a>
<br><br>

<div class="well">데이터 저장 시 데이터의 효율성을 향상시키기 위해 동일한 성격의 데이터를 동일한 블럭에 저장하는 물리적인 방법을 무엇이라고 하는가?</div>
<a href="#" class="btna">
    <span class="text">Text</span>
    <span class="flip-front">정답확인</span>
    <span class="flip-back">클러스트(Cluster)</span>
</a>
<br><br>

<div class="well">대용량의 테이블이나 인덱스를 작은 논리적 단위로 나누는 것을 무엇이라고 하는가?</div>
<a href="#" class="btna">
    <span class="text">Text</span>
    <span class="flip-front">정답확인</span>
    <span class="flip-back">파티션(Patition)</span>
</a>
<br><br>




