<h2>데이터 조작 프로시저 성능개선</h2>
<div class="well">
    - 프로그래밍 언어와 도구에 대한 이해를 바탕으로 응용소프트웨어 설계, 물리 데이터 저장소 설계와 운영 환경을 고려하여 데이터 조작 프로시저의 성능을 예측할 수 있다.<br>
    - 업무 분석가에 의해 정의된 요구사항을 기준으로, 성능측정 도구를 활용하여 데이터 조작 프로시저의 성능을 측정할 수 있다.<br>
    - 실 데이터를 기반으로 테스트를 수행하여 데이터 조작 프로시저의 성능에 영향을 주는 병목을 파악할 수 있다.<br>
    - 테스트 결과와 정의된 요구사항을 기준으로 데이터조작 프로시저의 성능에 따른 이슈 발생 시 이에 대해 해결할 수 있다.
</div>
<p>작성한 데이터 조작 프로시저를 적용하는 과정에서 성능개선이나 자원의 효율적 사용의 필요성이 제기되는바, 이를 해결하기 위해서는 성능 최적화 방안을 통해 업무의 중요도나 트랜잭션 빈도, 그리고 사용하는 사용자 수에 따라 우선순위를 부여한 뒤 우선순위가 높은 SQL부터 최적화를 진행하게 된다.</p>
<p>이런 성능 최적화는 무엇보다도 개발자 스스로가 최적화를 위한 필요지식을 학습하고 이해하여, 이를 습득함으로써 성능 최적화에 대한 부담을 줄이는 것이 무엇보다 우선적으로 필요하다.</p>
<p>관련 지식으로는 성능을 분석할 수 있는 1. APM(Application Performance Management)의 이해와, 2. 모니터링 결과 문제시되는 SQL에 대한 처리흐름, 그리고 3. 해당 SQL이 DBMS 내에서 어떻게 동작하는지를 파악할 수 있는 다양한 유틸리티(Oracle의 경우 TKPROF, EXPLAIN PLAN 등)를 활용하여 그 결과를 분석하는 방법 등이 있다.</p>


<h3>1. APM(Application Performance Management) 도구의 이해</h3>
<h4>1. APM 정의</h4>
<p>APM은 Application Performance Management(Monitoring)의 약자로서, 운영 중인 시스템에 대한 가용성 확보, 다운타임 최소화 등을 통해 안정적인 시스템 운영을 위하여, 부하량과 접속자 파악 및 장애진단 등을 목적으로 하는 성능 모니터링 도구를 말한다.</p>
<h4>2. APM 유형</h4>
<p>APM 유형은 크게 두가지(리소스, 엔드투엔드) 영역으로 나누어 정의해 볼 수 있다.</p>
<ul>
    <li>애플리케이션 수행시 리소스 모니터링
        <ul>
            <li>모니터링 대상 자원은 CPU, 메모리, 네트워크, 디스크 등이 있다.</li>
            <li>대표적인 오픈 소스로는 Nagios, Zabbix, Cacti 등이 있다.</li>
        </ul>
    </li>
    <li>애플리케이션 수행을 위한 엔드투엔드(End to End) 모니터링
        <ul>
            <li>모니터링 대상을 애플리케이션 수행 관점으로 보아, 비즈니스 트랜잭션 관리 및 최종 사용자 등 엔드투엔드 모니터링으로 본다.</li>
            <li>대표적인 오픈 소스로는 VisualVM이 있고, 상용 제품으로는 제니퍼, 파로스, 시스 마스터 등이 있다.</li>
        </ul>
    </li>
</ul>




<h3>2. SQL 처리 흐름</h3>
<h4>1. SQL 처리 흐름도</h4>
<h5>1. 구분분석 단계</h5>
<ul>
    <li>먼저, 사용자가 요청한 SQL문이 데이터베이스에서 처음 사용된 문장인지 이미 사용된 문장인지를 공유 풀 영역을 검색하여 확인한다. 이는 이미 사용된 문장이 라면 구문분석(Parsing)이라는 작업을 할 필요가 없고, 처음 사용되었다면 정상적 으로 구문분석 작업을 수행해야 하기 때문이다.</li>
    <li>작성된 SQL문이 문법에 따라 정상적으로 작성되었는지를 분석하고, SQL 내에 포 함된 테이블, 뷰 등이 데이터베이스에 존재하는 오브젝트인지를 확인한다.</li>
    <li>이후, 옵티마이저는 SQL문을 가장 빠르게 데이터를 검색해 줄 수 있는 실행계획 을 찾는다.</li>
</ul>

<h5>2. 실행 단계</h5>
<ul>
    <li>구문분석이 정상적으로 실행되면 서버 프로세스는 메모리 영역의 데이터베이스 버퍼 캐시영역을 검색하여 해당 테이블의 데이터가 다른 사용자의 다른 SQL문에 의해 이미 데이터버퍼 캐시영역에 존재하는지를 검색한다.</li>
    <li>데이터버퍼 캐시영역에 존재한다면, 테이블의 해당 데이터 파일로부터 테이블을 읽지 않고 캐시영역의 데이터를 그대로 추출한다.</li>
    <li>만약, 존재하지 않는다면 정의된 테이블의 해당 데이터 파일로부터 테이블을 읽어서 데이터버퍼 캐시영역에 저장한다.</li>
    <li>SQL문이 SELECT가 아닌 UPDATE, DELETE, INSERT문 등의 DML문장이었다면 데이터 버퍼캐시 영역에서 새로운 데이터로 변경, 삭제 또는 입력하게 된다.</li>
</ul>

<h5>3. 추출 단계</h5>
<ul>
    <li>실행단계가 끝나면 서버 프로세스는 데이터버퍼 캐시영역에서 관련 테이블 데이 터를 읽어서 사용자가 요청한 클라이언트로 보내주게 된다.
    </li>
    <li>SELECT문을 실행하는 경우에만 추출단계가 실행되고, UPDATE, INSERT, DELETE문 실행 시는 추출단계는 실행되지 않는다.</li>
</ul>

<h4>2. SQL 작성시 고려사항</h4>
<ul>
    <li>개발자는 SQL 특성을 충분히 이해하여 SQL문을 적절히 구사할 수 있는 능력을 기본 적으로 갖추어야 한다.</li>
    <li>사용자가 SQL 작성시, 옵티마이저가 실행계획을 수립한 후 실행되는 일련의 과정을 이해하고 작성하여야 한다.</li>
    <li>구문분석 단계시 옵티마이저가 수립한 실행계획에 따라 엄청난 수행속도 차이가 발 생할 수 있음을 이해하여야 한다.</li>
    <li>특정 SQL이 실행될 때 옵티마이저에 의해 수립된 실행계획은 제어하기가 어렵지만, 옵티마이저가 비정상적으로 동작된다면, 이를 추적하여 개발자가 원하는 실행계획으 로 동작될 수 있도록 조정하는 과정이 필요하다.</li>
    <li>무엇보다도 개발자는 옵티마이저가 정상적인 실행계획을 수립할 수 있도록 종합적이고 전략적인 포인트를 SQL에 부여하여 작성하여야 한다.</li>
    <li>좋은 SQL은, 추출되는 결과를 추론하여 SQL을 집합적으로 접근하여 작성하여야 한다.</li>
</ul>



<h3>3. SQL 성능 최적화를 위한 유틸리티 활용</h3>
<p>시장에서 많이 사용하고 있는 Oracle DBMS 경우, SQL 문제점을 파악하고 개선하여 SQL
    성능을 최적화하기 위해, TKPROF 및 EXPLAIN PLAN이라는 도구를 제공하고 있다.
    만약 SQL문이 적절히 작성되지 않았다면 전반적인 처리 효율성이 떨어질 수 있고, 이때 처리 성능의 통계치 정보를 파악하기 위해 TKPROF 도구 활용을 고려해야 하고, EXPALIN PLAN은 SQL이 사용하는 액세스 경로를 파악하기 위해 활용할 수 있는 도구이다.</p>

<h4>1. TKPROF 활용</h4>
<p>실행되는 SQL문장에 대해 분석정보를 제공하여 사용자(프로그래머,..)가 특정 SQL문장을 어떻게 사용해야 할 것인지에 대한 가이드라인을 제공해 주는 도구로서, EXPLAIN PLAN 과 병행하여 사용하는 것이 좋다.</p>

<h5>1. Trace 결과로 파악할 수 있는 분석정보 내용</h5>
<ul>
    <li>Parse, Execute, Fetch수</li>
    <li>CPU 시간/경과된 시간</li>
    <li>물리적/논리적 Reads</li>
    <li>처리된 로우수</li>
    <li>라이브러리 캐시 Misses</li>
    <li>파싱이 발생할 때의 사용자</li>
    <li>커밋(Commit)/롤백(Rollback)</li>
</ul>

<h5>2. Trace 유형</h5>
<ul>
    <li>Instance Level 추적
        <ul>
            <li>지속적인 설정 방법이다.</li>
            <li>모든 SQL 수행에 대한 Trace 파일을 생성하여 많은 부하가 발생한다.</li>
        </ul>
    </li>
    <li>Session Level 추적
        <ul>
            <li>임시적인 설정 방법이다.</li>
            <li>특정 프로세스별로 추적 파일을 생성한다.</li>
        </ul>
    </li>
</ul>

<h5>3. Trace 유형 활용</h5>
<ul>
    <li>Instance Level로 모든 SQL을 Trace하는 경우는 거의 없고, DB 응용프로그램에서 사용되는 특정 SQL에 대해서만 Trace하는 Session Level을 일반적으로 활용한다.</li>
    <li>Trace를 Enable하는 것은 DB 부하가 수반되므로, 필요할때만 사용하고 평상시 개발 및 운영환경에서는 Disable 하는것이 좋다.</li>
</ul>

<h5>4. Trace 관련 파라미터 설정 및 확인</h5>
<ul>
    <li>관련 파라미터
        <ul>
            <li>timed_statistics (default=false): CPU시간, 실행시간등 시간에 관련된 정보를 표시
                하기 위해 사용됨</li>
            <li>max_dump_file_size (default=500): Trace 파일의 최대 크기(단위: OS블럭수)</li>
        </ul>
    </li>
    <li>파라미터 설정 확인
        <ul>
            <li>Sys user로 DB connect: sqlplus “/ as sysdba”</li>
            <li>SQL Mode에서 show parameter 또는 show parameter parameter_name</li>
        </ul>
    </li>
</ul>

<h5>5. TKPROF 활용법</h5>
<p>SQL Trace가 생성한 Trace 파일을 분석하여 사용자가 읽을 수 있는 형태로 변환시켜 주는 Oracle 제공 도구이다.</p>